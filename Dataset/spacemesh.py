#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
# @Copyright (c) 2023 Baidu.com, Inc. All Rights Reserved
# @Time    : 2023/10/22 23:06
# @Author  : Liu Tianyuan (liutianyuan02@baidu.com)
# @File    : SpaceMesh.py
# @Description    : ******
"""

import numpy as np
from torch.utils.data import Dataset # todo: the Dataset should be replaced by general bkd.Dataset
from Module import bkd

from Utilizes.commons import default
from Dataset.data.mesh import MeshData
from Dataset._base_dataset import BasicDataset

from typing import Union, List, Dict, Tuple, Callable, Optional
type_time_slices = Union[list, tuple, int, np.ndarray]

class SpaceMeshDataSet(BasicDataset, Dataset):

    def __init__(self,
                 raw_data,
                 subset_name: str = None,
                 train_mode: bool = True,
                 time_interval: list or tuple = None,
                 time_slices: type_time_slices = 0,
                 *args, **kwargs):
        r"""
            SpaceMeshDataSet
            Args:
                :param raw_data: the raw data, should be a MeshData object or CustomMeshData object
                :param subset_name: the subset name, if None, then the subset name will be None
                :param train_mode: the train mode, if True, then the time sampling will be random
                :param time_interval: the time interval, if None, then the time interval will be generated by linspace
                :param time_slices: the time slices, if int, then the time slices will be generated by linspace
                :param args: the args
                :param kwargs: the kwargs
            Return:

        """
        super(SpaceMeshDataSet, self).__init__(
                                               raw_data,
                                               subset_name=None,
                                               input_name=None,
                                               output_name=None,
                                               train_mode=train_mode,
                                               time_interval=time_interval,
                                               time_slices=time_slices)

        self.subset_name = subset_name
        if self.subset_name is not None:
            self.mesh_points = self.raw_data.point_sets[self.subset_name]
            self.mesh_fields = self.raw_data.field_sets[self.subset_name]
        else:
            self.mesh_points = None
            self.mesh_fields = None

        if self.time_interval is not None:
            if isinstance(time_slices, int):
                self.time_slices = self._get_time_slices()
            elif isinstance(time_slices, (list, tuple)):
                self.time_slices = np.array(time_slices, dtype=np.float32)
            else:
                raise NotImplementedError("time_slices should be int, list or tuple")
        else:
            self.time_slices = 0

        self.check_data()

    def __getitem__(self, idx):
        if self.train_mode:
            # in train mode, the time sampling should be random !
            if self.time_interval is not None:
                points_size = self.mesh_points.shape[1:-1]
                time_stamp = self._get_time_random(points_size)
                if isinstance(self.mesh_points, np.ndarray):
                    return {'input': np.concatenate((self.mesh_points[idx], time_stamp), axis=-1),
                            'target': self.mesh_fields[idx]}
                elif isinstance(self.mesh_points, bkd.Tensor):
                    return {'input': bkd.cat((self.mesh_points[idx], bkd.tensor(time_stamp)), dim=-1),
                            'target': self.mesh_fields[idx]}
                else:
                    raise NotImplementedError("mesh_points should be np.ndarray or bkd.Tensor")
            else:
                return {'input': self.mesh_points[idx], 'target': self.mesh_fields[idx]}
        else:
            # in test mode, the time sampling should be fixed or equal to self.mesh_fields !
            if self.time_interval is not None:
                if isinstance(self.mesh_points, np.ndarray):
                    time_slices = np.tile(self.time_slices[idx], list(self.mesh_points.shape[:-1]) + [1])
                    return {'input': np.concatenate((self.mesh_points, time_slices), axis=-1),
                            'target': self.mesh_fields[idx]}
                elif isinstance(self.mesh_points, bkd.Tensor):
                    time_slices = bkd.tile(self.time_slices[idx], list(self.mesh_points.shape[:-1]) + [1])
                    return {'input': bkd.cat((self.mesh_points, bkd.tensor(time_slices)), dim=-1),
                            'target': self.mesh_fields[idx]}
                else:
                    raise NotImplementedError("mesh_points should be np.ndarray or bkd.Tensor")
            else:
                return {'input': self.mesh_points[idx], 'target': self.mesh_fields[idx]}

    def __len__(self):
        if self.train_mode or self.time_interval is None:
            return len(self.mesh_points)
        else:
            return len(self.time_slices)

    def check_data(self):
        r"""
            check the data
        """
        if not self.train_mode:
            if self.time_interval is not None:
                assert len(self.mesh_fields) == len(self.time_slices), \
                       "the length of time_slices should be equal to the length of mesh_fields"


    def load_file(self, file, file_type='msh'):
        r"""
            load the object from a file
            Any non-abstract dataset inherited from this class should implement this method.
            Args:
                file(str): The path of the file to save to
                file_type(str): The type of the file to save to
            Returns:
                None
        """
        mesh = MeshData(file)
        return mesh

    def save_file(self, file, file_type='msh'):
        r"""
            save the object to a file
            Any non-abstract dataset inherited from this class should implement this method.
            Args:
                file(str): The path of the file to save to
                file_type(str): The type of the file to save to
            Returns:
                None
        """
        self.raw_data.save_file(file, file_type=file_type)


    def _get_time_random(self, size=1):
        # todo: add more time sampling methods
        return np.random.uniform(self.time_interval[0],
                                 self.time_interval[1],
                                 size=size).astype(np.float32)[..., None]   # (N, 1)

    def _get_time_slices(self):
        return np.linspace(self.time_interval[0],
                           self.time_interval[1],
                           num=self.time_slices).astype(np.float32)[..., None] # (N, 1)


    def __call__(self,
                 subset_name: str,
                 train_mode: bool = True,
                 time_interval: list or tuple = None,
                 time_slices: int = 1,
                 *args, **kwargs):

        return SpaceMeshDataSet(raw_data=self.raw_data,
                                subset_name=subset_name,
                                train_mode=default(train_mode, self.train_mode),
                                time_slices=default(time_slices, self.time_slices),
                                time_interval=default(time_interval, self.time_interval),)

if __name__ == '__main__':

    # use a custom mesh class to test
    class Mesh(object):
        def __init__(self):
            self.point_sets = {'inlet': np.linspace(0, 100, 100).reshape(-1, 1),
                               'outlet': np.linspace(0, 100, 100).reshape(-1, 1)}
            self.field_sets = {'inlet': np.linspace(0, 100, 100).reshape(-1, 1),
                               'outlet': np.linspace(0, 100, 100).reshape(-1, 1)}


    mesh = Mesh()
    mesh_dataset = SpaceMeshDataSet(mesh, time_interval=None)
    outlet_dataset = mesh_dataset('outlet')

    print(outlet_dataset[0])

    # use a real mesh class to test
    mesh = MeshData('../demo/openatom_2d/data/raw_mesh/airfoil/case1/naca001065_aoa0_box12_4.msh')
    mesh_dataset = SpaceMeshDataSet(mesh, time_interval=[0, 1])
    outlet_dataset = mesh_dataset('airfoil')

    import matplotlib.pyplot as plt
    plt.scatter(outlet_dataset.mesh_points[:, 0], outlet_dataset.mesh_points[:, 1],
                c=outlet_dataset.mesh_fields[:, 0], cmap='jet')
    plt.show()